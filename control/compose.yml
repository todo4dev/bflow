name: "control"

networks:
  control:
    name: "control"

services:
  control-postgres:
    image: "postgres:15"
    hostname: "postgres"
    container_name: "control-postgres"
    networks: [ "control" ]
    ports: [ "${DOCKER_POSTGRES_PORT:?DOCKER_POSTGRES_PORT is required}:5432" ]
    environment:
      POSTGRES_USER: "${DOCKER_POSTGRES_USERNAME:?DOCKER_POSTGRES_USERNAME is required}"
      POSTGRES_PASSWORD: "${DOCKER_POSTGRES_PASSWORD:?DOCKER_POSTGRES_PASSWORD is required}"
      POSTGRES_DB: "${DOCKER_POSTGRES_DATABASE:?DOCKER_POSTGRES_DATABASE is required}"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  control-liquibase:
    image: "liquibase/liquibase:4.33-alpine"
    hostname: "liquibase"
    container_name: "control-liquibase"
    platform: "linux/amd64"
    networks: [ "control" ]
    depends_on:
      control-postgres:
        condition: "service_healthy"
    volumes: [ "./db/:/liquibase/changelog/" ]
    command: >
      bash -c "liquibase
      --url=jdbc:postgresql://control-postgres:5432/${DOCKER_POSTGRES_DATABASE}
      --searchPath=/liquibase/changelog
      --changeLogFile=changelog.xml
      --username=${DOCKER_POSTGRES_USERNAME}
      --password=${DOCKER_POSTGRES_PASSWORD}
      --databaseChangeLogTableName=_changelog
      --databaseChangeLogLockTableName=_changelog_lock
      updateToTag ${DOCKER_LIQUIBASE_TAG}"
      
  control-dragonfly:
    image: "dragonflydb/dragonfly:v1.27.1"
    hostname: "dragonfly"
    container_name: "control-dragonfly"
    networks: [ "control" ]
    ports: [ "${DOCKER_DRAGONFLY_PORT:?DOCKER_DRAGONFLY_PORT is required}:6379" ]
    ulimits:
      memlock:
        soft: -1
        hard: -1
    healthcheck:
      test: [ "CMD", "redis-cli", "-h", "localhost", "ping" ]
      interval: 5s
      timeout: 3s
      retries: 3
      start_period: 5s

  control-minio:
    image: "minio/minio:latest"
    hostname: "minio"
    container_name: "control-minio"
    networks: [ "control" ]
    ports:
      - "${DOCKER_MINIO_API_PORT:?DOCKER_MINIO_API_PORT is required}:9000"
      - "${DOCKER_MINIO_CONSOLE_PORT:?DOCKER_MINIO_CONSOLE_PORT is required}:9001"
    environment:
      MINIO_ROOT_USER: "${DOCKER_MINIO_ROOT_USER:?DOCKER_MINIO_ROOT_USER is required}"
      MINIO_ROOT_PASSWORD: "${DOCKER_MINIO_ROOT_PASSWORD:?DOCKER_MINIO_ROOT_PASSWORD is required}"
    command: "server /data --console-address :9001"
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS -o /dev/null http://localhost:9000/minio/health/live || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  control-minio-create-bucket:
    image: "minio/mc:latest"
    hostname: "minio-create-bucket"
    container_name: "control-minio-create-bucket"
    networks: [ "control" ]
    depends_on:
      control-minio:
        condition: "service_healthy"
    entrypoint: >
      /bin/sh -c " until /usr/bin/mc alias set minio http://control-minio:9000 ${DOCKER_MINIO_ROOT_USER} ${DOCKER_MINIO_ROOT_PASSWORD}; do
        sleep 2;
      done; /usr/bin/mc mb minio/${DOCKER_MINIO_BUCKET:?DOCKER_MINIO_BUCKET is required} || true; /usr/bin/mc anonymous set public minio/${DOCKER_MINIO_BUCKET} || true; exit 0; "

  control-kafka:
    image: "bitnamilegacy/kafka:4.0.0-debian-12-r10"
    hostname: "kafka"
    container_name: "control-kafka"
    networks: [ "control" ]
    ports: [ "${DOCKER_KAFKA_PORT:?DOCKER_KAFKA_PORT is required}:29092" ]
    environment:
      ALLOW_PLAINTEXT_LISTENER: "yes"
      KAFKA_CFG_NODE_ID: "1"
      KAFKA_CFG_PROCESS_ROLES: "controller,broker"
      KAFKA_CFG_CONTROLLER_QUORUM_VOTERS: "1@control-kafka:9093"
      KAFKA_CFG_LISTENERS: "PLAINTEXT://:9092,CONTROLLER://:9093,PLAINTEXT_HOST://:29092"
      KAFKA_CFG_ADVERTISED_LISTENERS: "PLAINTEXT://control-kafka:9092,PLAINTEXT_HOST://localhost:${DOCKER_KAFKA_PORT}"
      KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: "CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT"
      KAFKA_CFG_CONTROLLER_LISTENER_NAMES: "CONTROLLER"
      KAFKA_CFG_INTER_BROKER_LISTENER_NAME: "PLAINTEXT"
      KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE: "true"
    healthcheck:
      test: [ "CMD-SHELL", "kafka-topics.sh --bootstrap-server localhost:9092 --list" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  control-kafka-ui:
    image: "provectuslabs/kafka-ui:latest"
    hostname: "kafka-ui"
    container_name: "control-kafka-ui"
    networks: [ "control" ]
    depends_on:
      control-kafka:
        condition: "service_healthy"
    ports: [ "${DOCKER_KAFKA_UI_PORT:?DOCKER_KAFKA_UI_PORT is required}:8080" ]
    environment:
      KAFKA_CLUSTERS_0_NAME: "control"
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: "control-kafka:9092"
      DYNAMIC_CONFIG_ENABLED: "true"
    healthcheck:
      test: [ "CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
  
  control-glitchtip-create-database:
    image: "postgres:15-alpine"
    container_name: "control-glitchtip-create-database"
    networks: [ "control" ]
    depends_on:
      control-postgres:
        condition: "service_healthy"
    command: >
      sh -c "
        export PGPASSWORD=${DOCKER_POSTGRES_PASSWORD};
        until pg_isready -h control-postgres -U ${DOCKER_POSTGRES_USERNAME} -d ${DOCKER_POSTGRES_DATABASE}; do sleep 2; done;
        psql -h control-postgres -U ${DOCKER_POSTGRES_USERNAME} -d ${DOCKER_POSTGRES_DATABASE} -tc \"SELECT 1 FROM pg_database WHERE datname = '${DOCKER_GLITCHTIP_DATABASE}'\" | grep -q 1 || 
        createdb -h control-postgres -U ${DOCKER_POSTGRES_USERNAME} ${DOCKER_GLITCHTIP_DATABASE}"
            
  control-glitchtip:
    image: "glitchtip/glitchtip:latest"
    hostname: "glitchtip"
    container_name: "control-glitchtip"
    networks: [ "control" ]
    depends_on:
      control-postgres:
        condition: "service_healthy"
      control-glitchtip-create-database:
        condition: "service_completed_successfully"
    ports: [ "${DOCKER_GLITCHTIP_PORT:?DOCKER_GLITCHTIP_PORT is required}:8000" ]
    volumes: [ "./.env:/code/.env" ]
    environment:
      DATABASE_URL: "postgres://${DOCKER_POSTGRES_USERNAME}:${DOCKER_POSTGRES_PASSWORD}@control-postgres:5432/${DOCKER_GLITCHTIP_DATABASE}"
      REDIS_URL: "redis://control-dragonfly:6379/1"
      SECRET_KEY: "${DOCKER_GLITCHTIP_SECRET_KEY}"
      PORT: "8000"
      GLITCHTIP_DOMAIN: "http://localhost:${DOCKER_GLITCHTIP_PORT}"
      DJANGO_SUPERUSER_EMAIL: "${DOCKER_GLITCHTIP_EMAIL}"
      DJANGO_SUPERUSER_PASSWORD: "${DOCKER_GLITCHTIP_PASSWORD}"
      EXT_PORT: "${DOCKER_GLITCHTIP_PORT}"
    command: 
      - /bin/sh
      - -c
      - |
        ./manage.py migrate
        ./manage.py createsuperuser --no-input || true
        python manage.py shell <<'PYTHON_EOF'
        import os
        from django.apps import apps
        
        Organization = apps.get_model('organizations_ext', 'Organization')
        Project = apps.get_model('projects', 'Project')
        Team = apps.get_model('teams', 'Team')
        ProjectKey = apps.get_model('projects', 'ProjectKey')
        User = apps.get_model('users', 'User')

        user = User.objects.filter(is_superuser=True).first()
        if user:
            org, _ = Organization.objects.get_or_create(
                slug='default-org', 
                defaults={'name': 'Default Org'}
            )
            if not org.users.filter(id=user.id).exists():
                org.add_user(user, role='owner')
            
            team, _ = Team.objects.get_or_create(
                slug='default-team', 
                organization=org
            )
            
            project, created = Project.objects.get_or_create(
                slug='default-project',
                organization=org
            )
            
            team.projects.add(project)
            
            key = ProjectKey.objects.filter(project=project).first()
            if not key:
                key = ProjectKey.objects.create(project=project)
            
            public_key = key.public_key.hex
            project_id = project.id
            ext_port = os.getenv('EXT_PORT', '8000')
            new_dsn = f"http://{public_key}@localhost:{ext_port}/{project_id}"
            
            env_path = '.env'
            if os.path.exists(env_path):
                with open(env_path, 'r') as f:
                    lines = f.readlines()
                
                updated = False
                for i, line in enumerate(lines):
                    if line.strip().startswith('API_TRACE_URL'):
                        parts = line.split('=', 1)
                        if len(parts) == 2:
                            var_part = parts[0]
                            lines[i] = f'{var_part}= "{new_dsn}"\n'
                            updated = True
                            break
                
                if not updated:
                    if lines and not lines[-1].endswith('\n'):
                        lines[-1] += '\n'
                    lines.append(f'API_TRACE_URL      = "{new_dsn}"\n')
                
                with open(env_path, 'w') as f:
                    f.writelines(lines)
                print(f"--- [OK] API_TRACE_URL atualizado: {new_dsn} ---")
        PYTHON_EOF
        exec /code/bin/run-all-in-one.sh